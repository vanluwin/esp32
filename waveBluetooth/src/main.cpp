#include "BluetoothSerial.h"
#define NUM_SAMPLES 112

// Object for Bluetooth
BluetoothSerial ESP_BT;
bool connected = false;

static byte WaveFormTable[4][NUM_SAMPLES] = {
    // Sin wave
    {0x80, 0x83, 0x87, 0x8A, 0x8E, 0x91, 0x95, 0x98, 0x9B, 0x9E, 0xA2, 0xA5,
     0xA7, 0xAA, 0xAD, 0xAF, 0xB2, 0xB4, 0xB6, 0xB8, 0xB9, 0xBB, 0xBC, 0xBD,
     0xBE, 0xBF, 0xBF, 0xBF, 0xC0, 0xBF, 0xBF, 0xBF, 0xBE, 0xBD, 0xBC, 0xBB,
     0xB9, 0xB8, 0xB6, 0xB4, 0xB2, 0xAF, 0xAD, 0xAA, 0xA7, 0xA5, 0xA2, 0x9E,
     0x9B, 0x98, 0x95, 0x91, 0x8E, 0x8A, 0x87, 0x83, 0x80, 0x7C, 0x78, 0x75,
     0x71, 0x6E, 0x6A, 0x67, 0x64, 0x61, 0x5D, 0x5A, 0x58, 0x55, 0x52, 0x50,
     0x4D, 0x4B, 0x49, 0x47, 0x46, 0x44, 0x43, 0x42, 0x41, 0x40, 0x40, 0x40,
     0x40, 0x40, 0x40, 0x40, 0x41, 0x42, 0x43, 0x44, 0x46, 0x47, 0x49, 0x4B,
     0x4D, 0x50, 0x52, 0x55, 0x58, 0x5A, 0x5D, 0x61, 0x64, 0x67, 0x6A, 0x6E,
     0x71, 0x75, 0x78, 0x7C},
    // Triangular wave
    {0x80, 0x84, 0x89, 0x8D, 0x92, 0x96, 0x9B, 0x9F, 0xA4, 0xA8, 0xAD, 0xB2,
     0xB6, 0xBB, 0xBF, 0xC4, 0xC8, 0xCD, 0xD1, 0xD6, 0xDB, 0xDF, 0xE4, 0xE8,
     0xED, 0xF1, 0xF6, 0xFA, 0xFF, 0xFA, 0xF6, 0xF1, 0xED, 0xE8, 0xE4, 0xDF,
     0xDB, 0xD6, 0xD1, 0xCD, 0xC8, 0xC4, 0xBF, 0xBB, 0xB6, 0xB2, 0xAD, 0xA8,
     0xA4, 0x9F, 0x9B, 0x96, 0x92, 0x8D, 0x89, 0x84, 0x7F, 0x7B, 0x76, 0x72,
     0x6D, 0x69, 0x64, 0x60, 0x5B, 0x57, 0x52, 0x4D, 0x49, 0x44, 0x40, 0x3B,
     0x37, 0x32, 0x2E, 0x29, 0x24, 0x20, 0x1B, 0x17, 0x12, 0x0E, 0x09, 0x05,
     0x00, 0x05, 0x09, 0x0E, 0x12, 0x17, 0x1B, 0x20, 0x24, 0x29, 0x2E, 0x32,
     0x37, 0x3B, 0x40, 0x44, 0x49, 0x4D, 0x52, 0x57, 0x5B, 0x60, 0x64, 0x69,
     0x6D, 0x72, 0x76, 0x7B},
    // Sawtooth wave
    {0x00, 0x02, 0x04, 0x06, 0x09, 0x0B, 0x0D, 0x10, 0x12, 0x14, 0x16, 0x19,
     0x1B, 0x1D, 0x20, 0x22, 0x24, 0x27, 0x29, 0x2B, 0x2D, 0x30, 0x32, 0x34,
     0x37, 0x39, 0x3B, 0x3E, 0x40, 0x42, 0x44, 0x47, 0x49, 0x4B, 0x4E, 0x50,
     0x52, 0x54, 0x57, 0x59, 0x5B, 0x5E, 0x60, 0x62, 0x65, 0x67, 0x69, 0x6B,
     0x6E, 0x70, 0x72, 0x75, 0x77, 0x79, 0x7C, 0x7E, 0x80, 0x82, 0x85, 0x87,
     0x89, 0x8C, 0x8E, 0x90, 0x93, 0x95, 0x97, 0x99, 0x9C, 0x9E, 0xA0, 0xA3,
     0xA5, 0xA7, 0xA9, 0xAC, 0xAE, 0xB0, 0xB3, 0xB5, 0xB7, 0xBA, 0xBC, 0xBE,
     0xC0, 0xC3, 0xC5, 0xC7, 0xCA, 0xCC, 0xCE, 0xD1, 0xD3, 0xD5, 0xD7, 0xDA,
     0xDC, 0xDE, 0xE1, 0xE3, 0xE5, 0xE8, 0xEA, 0xEC, 0xEE, 0xF1, 0xF3, 0xF5,
     0xF8, 0xFA, 0xFC, 0xFE},
    // Square wave
    {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
     0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
     0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
     0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
     0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00}
};

int i = 0;
byte wave_type1 = 0;    // Sine
// byte wave_type = 1;  // Triangle
byte wave_type2 = 2;    // Sawtooth
// byte wave_type = 3;  // Square

// PolySolve correction function (without pow() for perfomase reasons)
double f(double x) {
    return 2.161282383460e+02 + 
           3.944594843419e-01 * x +
           5.395439724295e-04 * x * x + 
           -3.968558178426e-06 * x * x * x +
           1.047910519933e-08 * x * x * x * x +
           -1.479271312313e-11 * x * x * x * x * x +
           1.220894795714e-14 * x * x * x * x * x * x +
           -6.136200785076e-18 * x * x * x * x * x * x * x +
           1.910015248179e-21 * x * x * x * x * x * x * x * x +
           -3.566607830903e-25 * x * x * x * x * x * x * x * x * x +
           5.000280815521e-30 * x * x * x * x * x * x * x * x * x * x +
           3.434515045670e-32 * x * x * x * x * x * x * x * x * x * x * x +
           -1.407635444704e-35 * x * x * x * x * x * x * x * x * x * x * x * x +
           9.871816383223e-40 * x * x * x * x * x * x * x * x * x * x * x * x * x;
}

void connectionCallback(esp_spp_cb_event_t event, esp_spp_cb_param_t *param) {
    if (event == ESP_SPP_SRV_OPEN_EVT) {
        Serial.println("Client Connected");
        connected = true;
    } else if (event == ESP_SPP_CLOSE_EVT) {
        Serial.println("Client disconnected");
        connected = false;
    }
}

void setup() {
    Serial.begin(115200);

    // ADC config
    analogReadResolution(12);        // Set the samples bits 9-12
    analogSetWidth(12);              // Set the read resolution
    analogSetCycles(8);              // Cycles per sample 1-255
    analogSetSamples(1);             // Samples in the range
    analogSetClockDiv(1);            // Divider for the ADC clock 1-255
    analogSetAttenuation(ADC_11db);  // Input Attenuation ADC_(0, 2_5, 6, 11)db

    ESP_BT.register_callback(connectionCallback);

    if (!ESP_BT.begin("ESP32")) {
        Serial.println("An error occurred initializing Bluetooth");
    } else {
        Serial.println("Bluetooth initialized");
    }
}

void loop() {
    // Simulate a analogic wave
    dacWrite(25, WaveFormTable[wave_type1][i]);
    dacWrite(26, WaveFormTable[wave_type2][i]);
    i++;

    if (i >= NUM_SAMPLES) i = 0;

    // Check for bluetooth connectivity
    if (connected) {
        
        // ADC
        int ch1 = analogRead(36);
        int ch2 = analogRead(39);
        int ch3 = analogRead(34);
        int ch4 = analogRead(35);

        char data[20];
        snprintf(data, sizeof(data), "%d,%d,%d,%d", ch1, ch2, ch3, ch4);

        ESP_BT.println(data);

        // Debug in the serial
        // Serial.print(strcat("Sent: ", data));
    }

    delay(500);
}